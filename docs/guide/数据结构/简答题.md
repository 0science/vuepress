*
数据
** 
数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并 被计算机程序处理的符号的集合


*
数据元素
**
在计算机程序中通常作为一个整体进行考虑和处理

*
数据的基本单位
**
数据元素


*
数据项
**
数据记录中基本的，不可分的数据单位


*
数据结构中的最小单位
**
数据项


*
数据对象
**
性质相同的数据元素的集合，是数据的一个子集


*
程序与算法的关系
**
程序=数据结构+算法


*
数据结构
**
相互之间存在一种或多种特定关系的数据元素的集合


*
数据结构包括3个方面
**
逻辑结构
存储结构
对数据的运算


*
逻辑结构
**
对数据之间关系的描述，它与数据的存储结构无关， 同一种逻辑结构可以有多种存储结构


*
逻辑结构类别
**
集合
线性结构
树形结构
图状结构\网状结构
![](https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/1699629952559.png)


*
存储结构\物理结构
**
是数据的逻辑结构在计算机中的表示


*
存储结构\物理结构类别
**
顺序存储
链式存储
索引存储
散列存储


*
线性结构类别
**
线性表
栈
队列
数组
串


*
非线性结构类别
**
多维数组
广义表
树
图


*
算法
**
对特定问题求解步骤的一种描述，是指令的有限序列，其中每一条指令表示一个或 多个操作


*
算法特性
**
有穷性
确定性
可行性
输入
输出


*
有穷性
**
一个算法必须保证执行有限步之后结束


*
确定性
**
算法的每一步骤必须有确定的定义


*
输入
**
一个算法有0个或多个输入


*
输出
**
一个算法有一个或多个输出


*
可行性
**
所有操作都必须可以通过已经实现的基本操作进行运算，并在有限次内实现


*
算法设计的要求
**
正确性
可读性
健壮性
效率与低存储量需求


*
正确性
**
要求算法能够正确地执行预先规定的功能和性能要求


*
可读性
**
要求算法易于人的理解


*
健壮性
**
要求算法有很好的容错性，能够对不合理的数据进行检查


*
算法的效率
**
算法的执行时间


*
算法的存储量
**
算法执行过程中所需要的大存储空间


*
高效率与低存储量需求
**
算法执行时间短，占用存储空间小


*
时间复杂度
**
T(n)=0(f(n))
随问题规模n 的增大，算法执行时间的增长率和f(n)的增长率相同


*
空间复杂度
**
算法在运行时所需存储空间


*
就地算法
**
T(n)=O(1)
直接将待排序序列修改成有序序列


*
渐进时间复杂度
**
常对幂指阶
![](https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/1699765224135.png)


*
数据类型
**
值的集合和操作的集合


*
抽象数据类型
**
一个数学模型及定义在该模型上的一组操作


*
抽象数据类型组成
**
数据对象
数据关系
基本操作集


*
线性表的逻辑特性
**
数据元素之间的关系是一对一的关系
数据元素都是首尾相接的（除首尾）
每个元素最多只能有一个前驱和一个 后继


*
线性表的存储结构
**
顺序存储结构（顺序表）
链式存储结构（链表）


*
单链表
**
数据域和指针域，指针域有一个指针且指向下一节点的地址


*
双链表
*
指针域有两个指针，一个指针指向下一节点的地址，另一个指针指向上一节点的地址


*
循环单链表
**
最后一个节点的后继指向第一个节点的单链表


*
循环双链表
**
在双链表基础上，最后一个节点的后继指向第一个节点，第一个节点的前驱 指向最后一个节点。

*
静态链表
**
借助数组来描述线性表的链式存储结构


*
顺序存储与链式存储的优缺点
**
![](https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/1700035937204.png)


*
首元结点
**
第一个有元素的结点
  

*
头结点
**
首元结点前的无元素结点


*
头指针
**
指向第一个结点，有头指头，无头指首


*
栈
**
只允许在一端进行插入和删除操作的线性表


*
栈顶
**
进行插入操作的一端


*
栈底
**
进行删除操作的一端


*
队列
**
允许在一端插入而在另一端删除的线性表


*
队头
**
进行删除操作的一端


*
队尾
**
进行插入操作的一端


*
假溢出
**
系统作为队列用的存储区还没有满，但队列却发生了溢出


*
循环队列
**
将一维数组Queue[0] 到 Queue[MAX SIZE-1]看成是一个首尾相连接的圆环


*
栈的应用
**
表达式的转换和求值
函数调用
递归实现
深度优先搜索遍历


*
队列的应用
**
计算机系统中各种资源的管理
消息缓冲器的管理
广度优先搜索遍历


*
递归程序
**
一个函数在结束本函数前，直接或间接调用函数自身


*
串
**
由零个或者多个字符组成的有限序列


*
串的存储方式
**
定长顺序存储
动态分配
堆分配


*
模式匹配
**
第一个字符串(模式串) 在第二个字符串(主串)中的位置


*
KMP
**
消除了朴素的模式匹配算法中回溯问题，完成串的模式匹配。  


*
BM 
**
一种精确字符串匹配算法(区别于模糊匹配)


*
空格串
**
用空格组成的串，长度等于空格的个数


*
空串
**
不含任何字符的串，长度为零


*
树
**
包含n(n>0)个节点的有穷集合


*
树的存储结构
**
双亲表示法，孩子表示法， **孩子兄弟表示法


*
树的节点
**
包括一个数据元素以及若干指向其子树的分支


*
节点的度
**
节点拥有的子树


*
叶子\终端节点
**
度为0的节点


*
树的度
**
树内个节点的度的最大值


*
节点的层次
**
根节点为第1层


*
树的高度或深度
**
树中节点的最大层数


*
有序树
**
树中节点的子树从左到右是有次序的，不能交换


*
无序树
**
树中节点的子树从左到右是有次序的，可以交换


*
二叉树
**
每个节点至多有两棵子树，并且，二叉树的子树有左右之分， 其次序不能任意颠倒


*
二叉树性质
**
1.二叉树第i层上的节点数目最多为$$2^{n-1}$$(i≥1)。
2.深度为k的二叉树至多有$$2^{k-1}$$个节点(k≥1)。
3.包含n个节点的二叉树的高度至少为$$\log_{2}{(N-1)}$$或者$$\log_{2}{N-1}$$
4.在任意一棵二叉树中，若终端节点的个数为$$n_{0}$$, 度为2的节点数为$$n_{2}$$, 则 $$n_{0}$$=$$n_{0}$$+1


*
满二叉树
**
一棵高度为h,并且含有$$2^{n-1}$$个节点的二叉树


*
完全二叉树
**
二叉树的深度为h,除第h层外，其它各层(1～h-1)的节点数都达到最大个数，第h层所有的节点都连续集中在最左边


*
森林
**
m(m>=0)棵互不相交的树的集合


*
路径
**
两个节点之间所经过的节点序列


*
路径长度
**
路径上经过的边的个数


*
树的路径长度
**
树根到每一个节点的路径长度之和


*
树的带权路径长度（WPL）
**
树中所有叶子节点的带权路径长度之和


*
哈夫曼树
**
在含有N 个带权叶子节点的二叉树中，其中带权路径长度 (WPL) 最小的二叉树


*
二叉树的遍历
**
按某条搜索路径访问树中的每个节点，使得每个节点均被访问一次且
仅被访问一次


*
线索二叉树
**
按照某种遍历筹式对二叉树进行遍历，可以把二叉树中所有节点排序为一个线性序列


*
线索
**
指向直接前驱节点和指向直接后续节点的指针


*
完全二叉树
**
对于深度为K的，有n结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应


*
树与二叉树的区别
**
1.二叉树的度至多为2
2.二叉树有左右子树之分
3.二叉树允许为空


*
图
**
由非空顶点集V和边集E组成，记作G=(V,E)


*
图的存储结构
**
邻接矩阵
邻接表
十字链表
邻接多重表
边集数组


*
有向图
**
E为有向边的有限集合的图


*
无向图
**
E为无向边的有限集合的图


*
简单图
**
不存在重复边，不存在顶点到自身的边


*
无向完全图
**
在无向图中，若任意两个顶点之间都存在边


*
有向完全图
**
有向图中，若任意两个顶点之间存在方向相反的两条弧


*
子图
**
只有顶点和边的都为子集的图


*
连通
**
从顶点v 到顶点w存在路径


*
连通图
**
图G中任意两个顶点都是连通的


*
非连通图
**
图G中存在不连通的两个顶点


*
连通分量
**
无向图中的极大连通子图


*
强连通
**
从顶点V到顶点W和从W到V都存在路径

*
强连通图
**
图中任一对顶点都是强连通的


*
强连通分量
**
有向图中的极大强连通子图


*
生成树
**
包含图中所有顶点的一个极小连通子图


*
最小生成树
**
带权连通无向图中边的权值之和最小的生成树


*
回路
**
第一个顶点和最后一个顶点相同的路径


*
简单路径
**
一条路径上顶点不重复出现


*
简单回路
**
除了第一个顶点和最后一个顶点相同，其余各顶点都不重复出现的回路


*
带权路径长度
**
从一个顶点VO到另一个顶点V1的一条路径上所经过边的权值之和


*
最短路径
**
带权图中，带权路径长度最短的路径


*
图的遍历
**
从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中所有顶点访问 一次且仅访问一次


*
深度优先搜索
**
图中某顶点V 出发，在访问了V之后一次 从V的未被访问的邻接点出发做深度优先遍历，直到图中所有和V有路径相同的顶点都被访问到。


*
广度优先搜索
**
从顶点v 出发，访问了V之后依次访问V的各个 未被访问过的邻接顶点。再依次访问它们的邻接点，并使先被访问的顶点的的邻接点先于后 访问的顶点的邻接点。


*
AOV网
**
用有向无环图表示一个工程，顶点表示活动，有向边<Vi,Vj> 表示Vi 必须先于 Vj进行的关系


*
AOE网
**
在带权有向图中，以顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销


*
关键路径
**
在 AOE 网中，路径长度最长的路径


*
关键活动
**
关键路径上的所有活动


*
拓扑排序
**
对于任何连接自顶点u 到顶点v 的有向边<u,v>,在最后的排序结果中，顶点u总是在顶点v的前面






1、完全图

也叫简单完全图，假设一个图有 n 个顶点，那么如果任意两个顶点之间都有边的话，该图就 称为完全图。

2、连通、连通分量、强连通分量的概念，极大连通子图?极小连通子图?

在无向图中，若从顶点v 到顶点w 有路径存在，则称v 和 w 是连通的。图中任意两点是连通

的，则称图G 为连通图。无向图中的极大连通子图称为连通分量。

有向图中，若 v 到 w 和 w 到 v 都有路径存在，则称这两个点是强连通的。任一对顶点都是强 连通的，则此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量。

极大是要求该连通子图包含其所有的边(暗指无向图),亦为连通分量。

极小是在保持连通的情况下使边数最少的子图(暗指无向图),亦为最小生成树。

3、 对一个图进行遍历可以获得不同的遍历序列，那么导致得到不同遍历序列不唯一的因素

有哪些?

遍历不唯一的因素有：开始遍历的结点不同；存储结构不同；在邻接表情况下邻接点的顺序 不同。

4、 在什么情况下，Prim 算法和Kruskual 算法生成不同的最小生成树 MST?

在有相同权值边时生成不同的MST, 在这种情况下，用Prim 算 法 或Kruskual 算法会产生不

同 的 MST。

5、Prim 算法和 Kruskual 算法区别

Prim 算法是加点法，适合边稠密图； Kruskual    算法是一种按权值的递增次序选择合适边来 构造生成树的加边法，适合边稀疏而顶点较多的图。


## 第七章：排序

### 基本概念

**1.排序：** 重新排列表中的元素，使表中的元素满足按关键字递增或递减的过程。

**2.算法的稳定性：** 假 设Ri=Rj,   且在排序之前Ri 领先于Rj,   若在排序后的序列中Ri 仍然领 先于 Rj,   则称所用的排序算法是稳定的，反之则称所用的算法是不稳定的。

**3.内部排序：** 排序期间元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全 部同时存放在内存中，必须在排序的过程中根据要求不断的在内外存之间移动的排序。

**4.监视哨：** 临时存储和判断数组边界。

**5.插入排序：** 每次将一个待排序的记录，按关键字大小插入到前面已经排好序的子序列中，

直至全部记录插入完成。

**6.** **希尔排序：** 又称缩小增量排序，先将整个记录序列分割成若干子序列分别进行直接插入排 序，待整个序列中记录基本有序时，再对全体进行一次直接插入排序。

**7.冒泡排序：** 从前往后(或从后往前)两两比较相邻元素的值，若为逆序则交换，知道序列 比较完，既完成一趟冒泡排序。这一趟确定的最不元素不再参与比较，重复上述过程直到一 趟排序没有记录交换。

**8.快速排序：** 通过一趟排序将待排记录分司加独立两部分，其中一部分的关键字均比另一部 分小，分别对两部分再进行快速排序直至整个序列有序

**9.选择排序：** 每一趟在未排序的记录中选择最小的记录作为有序序列部分的下一个记录。

**10.归并排序：**将两个或两不以上的有序表组合成一个新的有序表。二路归并排序的核心操 作是将一维数组中前后相邻的网个有序序列归并为一个有序序列。

**11.基数排序：** 采用多关键字排序思想，借助“分配/收集”两种操作对逻辑关键字进行排序。

**12.堆** **排** **序** **：**一种树形选择排序方法。在排序过程中把L[1…N] 堪称一棵完全二叉树的顺序

存储结构，利用完全二叉树中双亲和孩子之间的关系，在当前无序区选择最大或最小的元素。 **13.堆：**堆常用来实现优先队列，在这种队列中，待删除的元素为优先级最高(最低)的那 个。在任何时候，任意优先元素都是可以插入到队列中去的，是计算机科学中一类特殊的数 据结构的统称。**【注意与栈的区别****】**

**14.桶排序：** 工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序(有可能再 使用别的排序算法或是以递归方式继续使用桶排序进行排序)。桶排序是鸽巢排序的一种归

纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间(J(n)) 。 但桶

排序并不是比较排序，他不受到0(nlog  n) 下限的影响。


### 简答题

1、 散列表存储的基本思想是什么?

散列表的基本思想是用关键字的值决定数据元素的农储地址

2、 散列表存储中解决碰撞的基本方法有哪些?

a、 开放定址法根据 di 的取值又分为线性探测再散列、二次探测再散列、伪随机探测再散 列

b 、再散列法

c、 链地址法

d 、建立公共溢出区

3、 如何衡量 hash 函数的优劣?

能否将关键字均匀映射到哈希空间上，有无好的解决冲突的方法，计算哈希函数是否简单高 效。由于哈希函数是压缩映像，冲突难以避免。

4、 在查找算法中，设置监视哨的作用是什么?

监视哨的作用是免去查找过程中每次都要检测整个表是否查找完毕，提高了查找效率。

5、 对于一个有序顺序表来说，折半查找是否任何时候比顺序查找快?为什么?

答：并非在任何情况下折半查找都比顺序查找快。例如，若待查元素是该顺序表的第一个元 素，则顺序查找顺序表会更快。对有序顺序表采用顺序查找，若元素存在表中，则在任一位 置，查找都可能成功。同样，若元素不在表中，则在任一位置，   查找都可能结束。折半查 找必须经一-系列计算，方知查找成功还是失败。尽管如此， 一般说来，在大多数情况下， 折半查找还是比顺序查找快。


## 第八章：查找

### 基本概念

**1.查找：** 在数据集合中寻找满足某种条件的数据元素的过程称为查找。

**2.查找表** (查找结构):用于查找的数据集合称为查找表。

**3.静态查找表：**如果一个查找表的操作仅涉及查询某个特定的数据元素是否在查找表中和检 索满足条件的某个特定的数据元素的各种属性，则称为静态查找表。

**4.****动****态查找表：** 需要动态的插入或删除的查找表称为动态查找表。

**5.关键字：** 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结

果应该是唯一的。

**6.平均查找长度** **(****ASL****):**  在查找的过程中， 一次查找的长度指需要比较的关键字次数，而平

均查找长度则是所有查找过程中进行关键字的比较次数的平均值。

**7.折半查找：** 仅适用于有序的顺序表。将给定的值key 与表中间位置元素的关键字比较，相 等则查找成功返回位置。若不等则缩小查找范围，重复查找直到找到或者确定表中没有需查

找的元素。

**8.二叉排序树：**一棵二叉排序树或是空二叉树或是具有以下性质的二叉树：左子树上所有关 键字均小于根节点的关键字，右子树所有节点关键字大于根节点的关键字。左子树和右子树 又各是一棵二叉排序树。

**9.平衡二叉树：** 树上任一节点的左子树和右子树的深度之差不超过1.

**10.平衡因子：** 该节点的左子树深度减去它的右子树深度。

**11.判定树：** 树中每个节点表示表中的一个记录，节点里的值为该记录在表中的位置，通常 称这个查找过程的二叉树为判定树。

**12.散列函数：** 一个把查找表中的关键字嘎射成该关键字对应的地址的函数，

**13.冲突(同义词):** 散列函数可能会把两心或以上的不同关键字映射到同一地址，这种情况

为冲突。

**14.散列表：** 是根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址指 间的一种直接映射关系。

**15.开放定址法：** 指的是可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同

义词表项开放。

**16.拉链法(链地址法):** 把所有的同义词存储在一个线性链表中，这个线性链表由其散列地

址唯一标识。

**17.装填因子：填入表中的元素个数/散列****表的长度。**

**18.二次聚集：** 指在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继 哈希地址的现象。

**19.再哈希法：这种方法是同时构造多个不同的哈希函数：**   H=RH₁(key)             i=1,2,  …,

k 。当哈希地址H=RH₁(key)    发生冲突时，再计算H=RH₂(key)……,         直到冲突不再产生。

这种方法不易产生聚集，但增加了计算时间。

**20.红黑树：** 红黑树是一种特定类型的二叉树，是在计算机科学中用到的一种数据结构，典 型的用途是实现关联数组。它是在1972年由 RudolfBayer    发明的，他称之为”对称二叉 B  树”,它现代的名字是在LeoJ.Guibas   和 RobertSedgewick    于1978年写的一篇论文中获得的。 它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的，它可以在 0(logn)时间内做查找，插入和删除，这里的n 是树中元素的数目。

**21.胜者树与败者树** ：胜者树和败者树都是完全二叉树，是树形选择排序的一种变型。每个 叶子节点相当于一个选手，每个中间节点相当于一场比赛，每一层相当于一轮比赛。

不同的是，胜者树的中间节点记录的是胜者的标号；而败者树的中间节点记录的败者的标号。


### 简答题

1、排序稳定性的概念

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的

相对次序保持不变，即在原序列中， r[i]=r[j],         且 r[i]   在 r[j]    之前，而在排序后的序列中，

r[i]  仍 在r[j]   之前，则称这种排序算法是稳定的。

2、 稳定排序有哪些?不稳定排序有哪些?

稳定排序：直接插入排序、冒泡排序、归并排序、基数排序

不稳定排序：选择排序、希尔排序、快速排序、堆排序

3、 快速排序是在所有情况下，排序速度最快的吗?为什么?

不是，因为当序列已有序时，快速排序退化成了冒泡排序，时间复杂度为0(n2)。

当待排序列无序，使每次划分完成后，枢轴 (pivot)      两侧子文件长度相当，此时快速排序

性能最好。

4、 比较次数与序列初态无关的算法是：二路归并排序、简单选择排序、基数排序

比较次数与序列初态有关的算法是：快速排序、直接插入排序、冒泡排序、堆排序、希 尔排序

5、 简述堆的结构

堆是一种特殊的完全二叉树，所有父结点都比子结点要小的完全二叉树我们称为最小堆。反 之，如果所有父结点都比子结点要大，这样的完全二叉树称为最大堆。


