"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[1807],{3298:(n,i,e)=>{e.r(i),e.d(i,{default:()=>d});var s=e(6252);const l=[(0,s.uE)('<h1 id="绪论" tabindex="-1"><a class="header-anchor" href="#绪论"><span>绪论</span></a></h1><h2 id="一、基本概念" tabindex="-1"><a class="header-anchor" href="#一、基本概念"><span>一、基本概念</span></a></h2><p><strong>数据结构学科</strong>：一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科</p><p><strong>数据</strong>：描述客观事物的符号</p><p><strong>数据元素</strong>：组成数据的，有一定意义的基本单位</p><p><strong>数据项</strong>：一个数据元素由若干数据项组成(最小单位)</p><p><strong>数据对象</strong>：相同数据元素的集合</p><p><strong>数据结构</strong>：相互存在一种或多种特定关系的数据元素集合</p><p><strong>逻辑结构</strong>：数据对象中数据元素之间的相互关系</p><p><strong>集合结构</strong>：数据元素属于统一集合</p><p><strong>线性结构</strong>：数据元素间是一对一的关系</p><p><strong>树形结构</strong>：数据元素间是一对多的关系</p><p><strong>图形结构</strong>：数据元素间是多对多的关系</p><p><strong>物理结构</strong>：计算机中的存储形式</p><p><strong>顺序存储结构</strong>：将数据元素存放在地址连续的存储单元里</p><p><strong>链式存储结构</strong>：将数据元素存放在任意的存储单元里</p><p><strong>数据类型</strong>： 一组性质相同的值的集合及定义在此集合上的一些操作</p><p><strong>原子类型</strong>：不可再分解的基本类型</p><p><strong>结构类型</strong>：由若干个类型组合而成，可再分解‘</p><p><strong>抽象</strong>：提取出事物具有的普遍性质</p><p><strong>抽象数据类型</strong>： 一个数学模型及定义在该模型上的一组操作</p><h2 id="二、算法" tabindex="-1"><a class="header-anchor" href="#二、算法"><span>二、算法</span></a></h2><h3 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义"><span>1.定义</span></a></h3><p>解决特定问题求解步骤的描述</p><h3 id="_2-算法的特性" tabindex="-1"><a class="header-anchor" href="#_2-算法的特性"><span>2.算法的特性</span></a></h3><ol><li><strong>输入输出</strong>：算法可以没有输入，但至少有一个输出</li><li><strong>有穷性</strong>：算法在执行有限步骤后会自动结束，每一步都在可接受的时间内完成</li><li><strong>确定性</strong>：算法的每一步都有确定的含义</li><li><strong>可行性</strong>：算法的每一步都可执行，每一步都能在有限执行次数内完成</li></ol><h3 id="_3-算法的要求" tabindex="-1"><a class="header-anchor" href="#_3-算法的要求"><span>3.算法的要求</span></a></h3><ol><li><strong>正确性</strong>：无歧义，正确得到答案，正确反应需求</li><li><strong>可读性</strong>：方便阅读、交流和理解</li><li><strong>健壮性</strong>：输入不合法时，能做出相关处理</li><li><strong>时间效率高</strong></li><li><strong>低存储需求</strong></li></ol><p><strong>算法的效率度量</strong>：</p><ol><li><strong>事后统计法</strong>：通过设计好的程序和数据，比较运行时间</li><li><strong>事前估计法</strong>：编程前估计算法输入规模</li><li><strong>输入规模</strong>：输入量的多少</li></ol><p><strong>算法的复杂度</strong>：</p><ol><li><strong>时间复杂度</strong>：算法执行时间的增长率随问题规模变化的函数</li><li><strong>空间复杂度</strong>：算法执行空间的增长率随问题规模变化的函数</li></ol><p><strong>大O记法</strong>：用大写的O()表示时间复杂度</p><ol><li>用1取代加法常数</li><li>只保留最高阶</li><li>去除最高阶系数</li></ol><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/202307281048338.png" alt=""></p><h1 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h1><h2 id="一、基本概念-1" tabindex="-1"><a class="header-anchor" href="#一、基本概念-1"><span>一、基本概念</span></a></h2><p><strong>线性表</strong>：n个数据元素的有限序列</p><p><strong>表长</strong>：线性表的元素个数n</p><p><strong>空表</strong>：n=0的线性表</p><p><strong>位序</strong>：数据元素的下</p><p><strong>表头</strong>：第一个元素</p><p><strong>表尾</strong>：最后一个元素</p><p><strong>前驱</strong>：元素左侧元素</p><p><strong>后继</strong>：元素右侧元素</p><p><strong>直接前驱</strong>：元素左侧相邻元素</p><p><strong>直接后继</strong>：元素右侧相邻元素</p><blockquote><p>每个元素都有前驱（除表首）<br> 每个元素都有后继（除表尾）</p></blockquote><p><strong>线性表的特点</strong>：</p><ol><li>元素个数有限</li><li>元素有先后顺序</li><li>每个元素都是数据元素</li><li>元素大小相同</li><li>元素具有抽象性</li></ol><h2 id="二、基本操作" tabindex="-1"><a class="header-anchor" href="#二、基本操作"><span>二、基本操作</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>InitList(&amp;L)       \\\\初始化表\nLength(L)          \\\\表长\nLocalElem(L,e)     \\\\按值查找\nGetElem(L,e)       \\\\按位查找\nListInsert(&amp;L,i,e) \\\\插入\nListDelete(&amp;L,i,e) \\\\删除\nPrintList(L)       \\\\输出\nEmpty(L)           \\\\判空\nDestroyList(L)     \\\\销毁\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/\nvoid unionL(SqList *La,SqList Lb)\n{\n\tint La_len,Lb_len,i;\n\tElemType e;                        /*声明与La和Lb相同的数据元素e*/\n\tLa_len=ListLength(*La);            /*求线性表的长度 */\n\tLb_len=ListLength(Lb);\n\tfor (i=1;i&lt;=Lb_len;i++)\n\t{\n\t\tGetElem(Lb,i,&amp;e);              /*取Lb中第i个数据元素赋给e*/\n\t\tif (!LocateElem(*La,e))        /*La中不存在和e相同数据元素*/\n\t\t\tListInsert(La,++La_len,e); /*插入*/\n\t}\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、顺序表" tabindex="-1"><a class="header-anchor" href="#三、顺序表"><span>三、顺序表</span></a></h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p><strong>顺序表</strong>：线性表的顺序存储，用一组地址连续的存储单元依次存储数据元素</p><p><strong>静态分配</strong>：数组大小和空间固定</p><p><strong>动态分配</strong>：在程序执行过程中分配空间</p><p><strong>地址</strong>：存储器中每个存储单元的编号</p><blockquote><p>线性表从1开始，数组从0开始<br> 线性表具备三个属性：起始位置、最大容量、当前长度<br> 线性表长度小于数组长度</p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">20</span>          </span><span class="token comment">/* 存储空间初始分配量 */</span></span>\n<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>       <span class="token comment">/* ElemType类型根据实际情况而定，这里为int */</span>\n<span class="token keyword">typedef</span> <span class="token keyword">struct</span>\n<span class="token punctuation">{</span>\n    ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 数组，存储数据元素 */</span>\n    <span class="token keyword">int</span> length<span class="token punctuation">;</span>             <span class="token comment">/* 线性表当前长度 */</span>\n<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>顺序表的优缺点</strong></p><ol><li>随机访问，可直接查找特定节点</li><li>存储密度高</li><li>逻辑相邻且物理相邻</li><li>插入删除移动大量元素</li><li>造成空间碎片化</li></ol><h3 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作"><span>基本操作</span></a></h3><h3 id="读取" tabindex="-1"><a class="header-anchor" href="#读取"><span>读取</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span>\n<span class="token comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span>\n<span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span>         \n\n<span class="token comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span>\n<span class="token comment">/* 操作结果：用e返回L中第i个数据元素的值，注意i是指位置，第1个位置的数组是从0开始 */</span>\nStatus <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> i<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span>\n        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>\n    <span class="token operator">*</span>e<span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h3><ol><li>插入位置不合理，则显示异常</li><li>线性表长度大于数组长度，则显示异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第个元素，并将其向后移动一位</li><li>将元素插入该位置</li><li>表长加一</li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */\n/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */\nStatus ListInsert(SqList *L,int i,ElemType e)\n{ \n\tint k;\n\tif (L-&gt;length==MAXSIZE)  \t\t\t/* 顺序线性表已经满 */\n\t\treturn ERROR;\n\tif (i&lt;1 || i&gt;L-&gt;length+1)\t\t\t/* 当i比第一位置小或者比最后一位置后一位置还要大时 */\n\t\treturn ERROR;\t\t\t\t\n\n\tif (i&lt;=L-&gt;length)        \t\t\t/* 若插入数据位置不在表尾 */\n\t{\n\t\tfor(k=L-&gt;length-1;k&gt;=i-1;k--)  \t/* 将要插入位置后的元素向后移一位 */\n\t\t\tL-&gt;data[k+1]=L-&gt;data[k];\n\t}\n\tL-&gt;data[i-1]=e;          \t\t\t/* 将新元素插入 */\n\tL-&gt;length++;\n\n\treturn OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h3><ol><li>位置不合理，则显示异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历到最后一个元素，并将其前移一位</li><li>表长减一</li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */\n/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */\nStatus ListDelete(SqList *L,int i,ElemType *e) \n{ \n\tint k;\n\tif (L-&gt;length==0)               /* 线性表为空 */\n\t\treturn ERROR;\n\tif (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */\n\t\treturn ERROR;\n\t*e=L-&gt;data[i-1];\n\tif (i&lt;L-&gt;length)                /* 如果删除不是最后位置 */\n\t{\n\t\tfor(k=i;k&lt;L-&gt;length;k++)\t/* 将删除位置后继元素前移 */\n\t\t\tL-&gt;data[k-1]=L-&gt;data[k];\n\t}\n\tL-&gt;length--;\n\treturn OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、单链表" tabindex="-1"><a class="header-anchor" href="#四、单链表"><span>四、单链表</span></a></h2><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1"><span>基本概念</span></a></h3><p><strong>单链表</strong>：线性表的链式存储，用任意一组存储单元存储元素</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-7.jpg" alt=""></p><p><strong>头指针</strong>：链表中第一个节点的存储位置，有头结点则指向头结点(<strong>必备</strong>)</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-8.jpg" alt=""></p><p><strong>头结点</strong>：单链表第一个结点前附加的一个结点</p><p><strong>数据域</strong>：存储信息元素的域(<strong>p-&gt;data</strong>)</p><p><strong>指针域</strong>：存储直接后继的位置(<strong>p-&gt;next</strong>)</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-10.jpg" alt=""></p><p><strong>空链表</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/20230812133616.png" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 线性表的单链表存储结构 */\ntypedef struct Node\n{\n    ElemType data;\n    struct Node *next;\n} Node;\n/* 定义LinkList */\ntypedef struct Node *LinkList;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>单链表优缺点</strong></p><ol><li>无需连续存储单元</li><li>指针域会浪费空间</li><li>非随机存取，无法直接查找特定节点</li></ol><h3 id="基本操作-1" tabindex="-1"><a class="header-anchor" href="#基本操作-1"><span>基本操作</span></a></h3><h4 id="读取-1" tabindex="-1"><a class="header-anchor" href="#读取-1"><span>读取</span></a></h4><ol><li>声明指针p指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则返回结点p的数据</li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L) */\n/* 操作结果：用e返回L中第i个数据元素的值 */\nStatus GetElem(LinkList L, int i, ElemType *e)\n{\n    int j;\n    LinkList p;            /* 声明一指针p */\n    p = L-&gt;next;        /* 让p指向链表L的第个结点 */\n    j = 1;                 /* j为计数器 */\n    /* p不为空且计数器j还没有等于i时，循环继续 */\n    while (p &amp;&amp; j &lt; i)    \n    {\n        p = p-&gt;next;    /* 让p指向下一个结点 */\n        ++j;\n    }\n    if (!p || j &gt; i)\n        return ERROR;      /* 第i个结点不存在 */\n    *e = p-&gt;data;       /* 取第i个结点的数据 */\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="插入-1" tabindex="-1"><a class="header-anchor" href="#插入-1"><span>插入</span></a></h4><p><strong>单链表的插入</strong></p><table><thead><tr><th><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-2.jpg" alt=""></th><th><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-3.jpg" alt=""></th></tr></thead></table><p><strong>表头/表尾的插入</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-4.jpg" alt=""></p><ol><li>声明p指针指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则生成空结点s</li><li>s-&gt;data = e</li><li>s-&gt;next = p-&gt;next</li><li>p-&gt;next = s</li><li>返回成功</li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L)， */\n/* 操作结果：在L中第i个结点位置之前插入新的数\n   据元素e，L的长度加1 */\nStatus ListInsert(LinkList *L, int i, ElemType e)\n{\n    int j;\n    LinkList p, s;\n    p = *L;\n    j = 1;\n    /* 寻找第i-1个结点 */\n    while (p &amp;&amp; j &lt; i)                     \n    {\n        p = p-&gt;next;\n        ++j;\n    }\n    /* 第i个结点不存在 */\n    if (!p || j &gt; i)\n        return ERROR;                      \n    /* 生成新结点（C标准函数） */\n    s = (LinkList)malloc(sizeof(Node));    \n    s-&gt;data = e;\n    /* 将p的后继结点赋值给s的后继 */\n    s-&gt;next = p-&gt;next;                    \n    /* 将s赋值给p的后继 */\n    p-&gt;next = s;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除-1" tabindex="-1"><a class="header-anchor" href="#删除-1"><span>删除</span></a></h4><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-5.jpg" alt=""></p><ol><li>声明p指针指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则q = p-&gt;next</li><li>p-&gt;next = q-&gt;next</li><li>e = q-&gt;data</li><li>释放q结点</li><li>返回成功</li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L) */\n/* 操作结果：删除L的第i个结点，并用e返回其\n   值，L的长度减1 */\nStatus ListDelete(LinkList *L, int i, ElemType *e)\n{\n    int j;\n    LinkList p, q;\n    p = *L;\n    j = 1;\n    /* 遍历寻找第i-1个结点 */\n    while (p-&gt;next &amp;&amp; j &lt; i)    \n    {\n        p = p-&gt;next;\n        ++j;\n    }\n    /* 第i个结点不存在 */\n    if (!(p-&gt;next) || j &gt; i)\n        return ERROR;           \n    q = p-&gt;next;\n    /* 将q的后继赋值给p的后继 */\n    p-&gt;next = q-&gt;next;          \n    /* 将q结点中的数据给e */\n    *e = q-&gt;data;               \n    /* 让系统回收此结点，释放内存 */\n    free(q);                    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="整表创建" tabindex="-1"><a class="header-anchor" href="#整表创建"><span>整表创建</span></a></h3><p><strong>头插法</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-9-1.jpg" alt=""></p><ol><li>声明指针p和变量i</li><li>初始化空链表L</li><li>建立带头结点的空表(头结点指向NULL)</li><li>循环： <ol><li>生成新节点，并赋值给p</li><li>随机生成数赋值给p的数据域</li><li>将p插入到头结点与新结点之间</li></ol></li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 随机产生n个元素的值，建立带表头结点的单链\n   线性表L（头插法） */\nvoid CreateListHead(LinkList *L, int n)\n{\n    LinkList p;\n    int i;\n    /* 初始化随机数种子 */\n    srand(time(0));                            \n    *L = (LinkList)malloc(sizeof(Node));\n    /* 先建立一个带头结点的单链表 */\n    (*L)-&gt;next = NULL;                         \n    for (i = 0; i &lt; n; i++)\n    {\n        /* 生成新结点 */\n        p = (LinkList)malloc(sizeof(Node));    \n        /* 随机生成100以内的数字 */\n        p-&gt;data = rand() % 100 + 1;            \n        p-&gt;next = (*L)-&gt;next;\n        /* 插入到表头 */\n        (*L)-&gt;next = p;                        \n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>尾插法</strong></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 随机产生n个元素的值，建立带表头结点的单链\n线性表L（尾插法） */\nvoid CreateListTail(LinkList *L, int n)\n{\n    LinkList p,r;\n    int i;\n    /* 初始化随机数种子 */\n    srand(time(0));                         \n    /* 为整个线性表 */\n    *L = (LinkList)malloc(sizeof(Node));    \n    /* r为指向尾部的结点 */\n    r = *L;                                 \n    for (i = 0; i &lt; n; i++)\n    {\n        /* 生成新结点 */\n        p = (Node *)malloc(sizeof(Node));   \n        /* 随机生成100以内的数字 */\n        p-&gt;data = rand() % 100 + 1;         \n        /* 将表尾终端结点的指针指向新结点 */\n        r-&gt;next = p;                        \n        /* 将当前的新结点定义为表尾终端结点 */\n        r = p;                              \n    }\n    /* 表示当前链表结束 */\n    r-&gt;next = NULL;                         \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="整表删除" tabindex="-1"><a class="header-anchor" href="#整表删除"><span>整表删除</span></a></h3><ol><li>声明指针p和q</li><li>将头结点赋值给p</li><li>循环： <ol><li>将下一结点赋值给q</li><li>释放p</li><li>将q赋值给p</li></ol></li></ol><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：顺序线性表L已存在，操作结果：将L\n   重置为空表 */\nStatus ClearList(LinkList *L)\n{\n    LinkList p, q;\n    /* p指向第一个结点 */\n    p = (*L)-&gt;next;       \n    /* 没到表尾 */\n    while (p)             \n    {\n        q = p-&gt;next;\n        free(p);\n        p=q;\n    }\n    /* 头结点指针域为空 */\n    (*L)-&gt;next = NULL;    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>线性表</th><th>存储方式</th><th>时间性能</th><th>空间性能</th><th>适用</th></tr></thead><tbody><tr><td>顺序表</td><td>连续存储</td><td>查找O(1) 插入O(n) 删除O(n)</td><td>预分配空间</td><td>频繁查找，很少插入删除</td></tr><tr><td>单链表</td><td>链式存储</td><td>查找O(n) 插入O(n) 删除O(n)</td><td>自由分配空间</td><td>元素个数多，变化大</td></tr></tbody></table><h2 id="五、静态链表" tabindex="-1"><a class="header-anchor" href="#五、静态链表"><span>五、静态链表</span></a></h2><h3 id="基本概念-2" tabindex="-1"><a class="header-anchor" href="#基本概念-2"><span>基本概念</span></a></h3><p><strong>静态链表</strong>：用数组描述的链表</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-1.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 线性表的静态链表存储结构 */\n/* 假设链表的最大长度是1000 */\n#define MAXSIZE 1000                     \ntypedef struct\n{\n    ElemType data;\n    /* 游标（Cursor），为0时表示无指向 */\n    int cur;                             \n} Component, \n  /* 对于不提供结构struct的程序设计语言，\n     可以使用一对并行数组data和cur来处理。 */\n  StaticLinkList[MAXSIZE];\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 若备用空间链表非空，则返回分配的结点下标，\n   否则返回0 */\nint Malloc_SLL(StaticLinkList space)\n{\n    /* 当前数组第一个元素的cur存的值， */\n    /* 就是要返回的第一个备用空闲的下标 */\n    int i = space[0].cur;               \n    /* 由于要拿出一个分量来使用了，所以我们 */\n    /* 就得把它的下一个分量用来做备用 */\n    if (space[0].cur)\n        space[0].cur = space[i].cur;    \n    return i;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>静态链表的优缺点</strong></p><ol><li>插入删除只改游标，不动元素</li><li>无法确定表长</li><li>无法随机读取</li></ol><h3 id="基本操作-2" tabindex="-1"><a class="header-anchor" href="#基本操作-2"><span>基本操作</span></a></h3><h4 id="插入-2" tabindex="-1"><a class="header-anchor" href="#插入-2"><span>插入</span></a></h4><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 若备用空间链表非空，则返回分配的结点下标，\n   否则返回0 */\nint Malloc_SLL(StaticLinkList space)\n{\n    /* 当前数组第一个元素的cur存的值， */\n    /* 就是要返回的第一个备用空闲的下标 */\n    int i = space[0].cur;               \n    /* 由于要拿出一个分量来使用了，所以我们 */\n    /* 就得把它的下一个分量用来做备用 */\n    if (space[0].cur)\n        space[0].cur = space[i].cur;    \n    return i;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 在L中第i个元素之前插入新的数据元素e  */\n  Status ListInsert(StaticLinkList L, int i, ElemType e)\n  {\n      int j, k, l;\n      /* 注意k首先是最后一个元素的下标 */\n      k = MAX_SIZE - 1;                   \n      if (i &lt; 1 || i &gt; ListLength(L) + 1)\n          return ERROR;\n      /* 获得空闲分量的下标 */\n      j = Malloc_SSL(L);                  \n      if (j)\n      {\n         /* 将数据赋值给此分量的data */\n         L[j].data = e;                  \n         /* 找到第i个元素之前的位置 */\n         for (l = 1; l &lt;= i - 1; l++)    \n             k = L[k].cur;\n         /* 把第i个元素之前的cur赋值给新元素的cur */\n         L[j].cur = L[k].cur;        \n         /* 把新元素的下标赋值给第i个元素之前元素的cur */\n         L[k].cur = j;                   \n         return OK;\n     }\n     return ERROR;\n }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除-2" tabindex="-1"><a class="header-anchor" href="#删除-2"><span>删除</span></a></h4><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-4.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 删除在L中第i个数据元素e */\nStatus ListDelete(StaticLinkList L, int i)\n{\n    int j, k;\n    if (i &lt; 1 || i &gt; ListLength(L))\n        return ERROR;\n    k = MAX_SIZE - 1;\n    for (j = 1; j &lt;= i - 1; j++)\n        k = L[k].cur;\n    j = L[k].cur;\n    L[k].cur = L[j].cur;\n    Free_SSL(L, j);\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 将下标为k的空闲结点回收到备用链表 */\nvoid Free_SSL(StaticLinkList space, int k)\n{\n    /* 把第一个元素cur值赋给要删除的分量cur */\n    space[k].cur = space[0].cur;    \n    /* 把要删除的分量下标赋值给第一个元素的cur */\n    space[0].cur = k;               \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 初始条件：静态链表L已存在。操作结果：返回L\n   中数据元素个数 */\nint ListLength(StaticLinkList L)\n{\n    int j = 0;\n    int i = L[MAXSIZE - 1].cur;\n    while (i)\n    {\n        i = L[i].cur;\n        j++;\n    }\n    return j;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、循环链表" tabindex="-1"><a class="header-anchor" href="#六、循环链表"><span>六、循环链表</span></a></h2><h3 id="基本概念-3" tabindex="-1"><a class="header-anchor" href="#基本概念-3"><span>基本概念</span></a></h3><p><strong>循环链表</strong>：将链表末端空指针改为指向头节点</p><p><strong>空循环链表</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-3.jpg" alt=""></p><p><strong>非空循环链表</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-4.jpg" alt=""></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-5.jpg" alt=""></p><h3 id="基本操作-3" tabindex="-1"><a class="header-anchor" href="#基本操作-3"><span>基本操作</span></a></h3><p><strong>合并链表</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-7.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 保存A表的头结点，即① */\np = rearA-&gt;next;                    \n/*将本是指向B表的第一个结点（不是头结点） */\nrearA-&gt;next = rearB-&gt;next-&gt;next;    \n/* 赋值给reaA-&gt;next，即② */\nq = rearB-&gt;next;\n/* 将原A表的头结点赋值给rearB-&gt;next，即③ */\nrearB-&gt;next = p;                    \n/* 释放q */\nfree(q);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="七、双向链表" tabindex="-1"><a class="header-anchor" href="#七、双向链表"><span>七、双向链表</span></a></h2><h3 id="基本概念-4" tabindex="-1"><a class="header-anchor" href="#基本概念-4"><span>基本概念</span></a></h3><p><strong>双向链表</strong>：单链表的每个结点中设置一个指向前驱的指针域</p><p><strong>空双向链表</strong></p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-3.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 线性表的双向链表存储结构 */\ntypedef struct DulNode\n{\n    ElemType data;\n    struct DuLNode *prior;    /* 直接前驱指针 */\n    struct DuLNode *next;     /* 直接后继指针 */\n} DulNode, *DuLinkList;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基本操作-4" tabindex="-1"><a class="header-anchor" href="#基本操作-4"><span>基本操作</span></a></h3><h4 id="插入-3" tabindex="-1"><a class="header-anchor" href="#插入-3"><span>插入</span></a></h4><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-5.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 把p赋值给s的前驱，如图中① */\ns-&gt;prior = p;          \n/* 把p-&gt;next赋值给s的后继，如图中② */\ns-&gt;next = p-&gt;next;     \n/* 把s赋值给p-&gt;next的前驱，如图中③ */\np-&gt;next-&gt;prior = s;    \n/* 把s赋值给p的后继，如图中④ */\np-&gt;next = s;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除-3" tabindex="-1"><a class="header-anchor" href="#删除-3"><span>删除</span></a></h4><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-6.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */\np-&gt;prior-&gt;next = p-&gt;next;     \n/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */\np-&gt;next-&gt;prior = p-&gt;prior;    \n/* 释放结点 */\nfree(p);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="栈、队列与数组" tabindex="-1"><a class="header-anchor" href="#栈、队列与数组"><span>栈、队列与数组</span></a></h1><h2 id="一、栈" tabindex="-1"><a class="header-anchor" href="#一、栈"><span>一、栈</span></a></h2><h3 id="基本概念-5" tabindex="-1"><a class="header-anchor" href="#基本概念-5"><span>基本概念</span></a></h3><p><strong>栈</strong>：只允许在一段插入或删除的线性表(后进先出)</p><p><strong>进栈(push)</strong>：栈的插入</p><p><strong>出栈(pop)</strong>：栈的删除</p><p><strong>栈顶</strong>：允许插入或删除的一段</p><p><strong>栈底</strong>：不允许插入或删除的一段</p><p><strong>空栈</strong>：不含任何元素的空表</p><p><strong>顺序栈</strong>：采用顺序存储的栈</p><p><strong>共享栈</strong>：可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分<br> 别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-5-1.jpg" alt=""></p><p><strong>链栈</strong>：采用链式存储的栈</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-1.jpg" alt=""></p><h2 id="基本操作-5" tabindex="-1"><a class="header-anchor" href="#基本操作-5"><span>基本操作</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>InitStack(*S):    初始化操作，建立一个空栈S。\nDestroyStack(*S): 若栈存在，则销毁它。\nClearStack(*S):   将栈清空。\nStackEmpty(S):    若栈为空，返回true，否则返回false。\nGetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。\nPush(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。\nPop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。\nStackLength(S):   返回栈S的元素个数。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="顺序存储" tabindex="-1"><a class="header-anchor" href="#顺序存储"><span>顺序存储</span></a></h2><h2 id="结构定义" tabindex="-1"><a class="header-anchor" href="#结构定义"><span>结构定义</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* SElemType类型根据实际情况而定，这里假设为int */\ntypedef int SElemType;    \ntypedef struct\n{\n    SElemType data[MAXSIZE];\n    /* 用于栈顶指针 */\n    int top;              \n}SqStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>栈顶指针：S.top<br> 初始时设置：S.top=-1<br> 栈顶元素：S.data[S.top]<br> 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素<br> 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1<br> 栈空条件：S.top==-1<br> 栈满条件：S.top==MaxSize-1<br> 栈长：S.top+1</p><h2 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>void Initstack(SqStack &amp;S){\n\tS.top=-1;                //初始化栈顶指针\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="判栈空" tabindex="-1"><a class="header-anchor" href="#判栈空"><span>判栈空</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>bool StackEmpty(Sqstack S){\n\tif(S.top==-1)            //栈空\n\t\treturn true;\n\telse                     //不空\n\t\treturn false;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进栈" tabindex="-1"><a class="header-anchor" href="#进栈"><span>进栈</span></a></h2><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-2.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(SqStack *S, SElemType e)\n{\n    /* 栈满 */\n    if (S-&gt;top == MAXSIZE - 1)    \n    {\n        return ERROR;\n    }\n    /* 栈顶指针增加一 */\n    S-&gt;top++;                     \n    /* 将新插入元素赋值给栈顶空间 */\n    S-&gt;data[S-&gt;top] = e;          \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="出栈" tabindex="-1"><a class="header-anchor" href="#出栈"><span>出栈</span></a></h2><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-3.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(SqStack *S, SElemType *e)\n{\n    if (S-&gt;top == -1)\n        return ERROR;\n    /* 将要删除的栈顶元素赋值给e */\n    *e = S-&gt;data[S-&gt;top];    \n    /* 栈顶指针减一 */\n    S-&gt;top--;                \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="读栈顶元素" tabindex="-1"><a class="header-anchor" href="#读栈顶元素"><span>读栈顶元素</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>bool GetTop(SqStack S,ElemType &amp;x){\n\tif(S.top==-1)                   //栈空，报错\n\t\treturn false;\n\tx=S.data[S.top];                //x记录栈顶元素\n\t\treturn true;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="共享栈" tabindex="-1"><a class="header-anchor" href="#共享栈"><span>共享栈</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 两栈共享空间结构 */\ntypedef struct\n{\n    SElemType data[MAXSIZE];\n    int top1;    /* 栈1栈顶指针 */\n    int top2;    /* 栈2栈顶指针 */\n} SqDoubleStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(SqDoubleStack *S, SElemType e, \nint stackNumber)\n{\n    /* 栈已满，不能再push新元素了 */\n    if (S-&gt;top1 + 1 == S-&gt;top2)    \n        return ERROR;\n    /* 栈1有元素进栈 */\n    if (stackNumber == 1)          \n        /* 若栈1则先top1+1后给数组元素赋值 */\n        S-&gt;data[++S-&gt;top1] = e;    \n    /* 栈2有元素进栈 */\n    else if (stackNumber == 2)     \n        /* 若栈2则先top2-1后给数组元素赋值 */\n        S-&gt;data[--S-&gt;top2] = e;    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(SqDoubleStack *S, SElemType *e, int stackNumber)\n{\n    if (stackNumber == 1)\n    {\n        /* 说明栈1已经是空栈，溢出 */\n        if (S-&gt;top1 == -1)\n            return ERROR;           \n        /* 将栈1的栈顶元素出栈 */\n        *e = S-&gt;data[S-&gt;top1--];    \n    }\n    else if (stackNumber == 2)\n    {\n        /* 说明栈2已经是空栈，溢出 */\n        if (S-&gt;top2 == MAXSIZE)\n            return ERROR;           \n        /* 将栈2的栈顶元素出栈 */\n        *e = S-&gt;data[S-&gt;top2++];    \n    }\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="链式存储" tabindex="-1"><a class="header-anchor" href="#链式存储"><span>链式存储</span></a></h2><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>typedef struct StackNode\n{\n    SElemType data;\n    struct StackNode *next;\n} StackNode, *LinkStackPtr;\ntypedef struct LinkStack\n{\n    LinkStackPtr top;\n    int count;\n} LinkStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进栈-1" tabindex="-1"><a class="header-anchor" href="#进栈-1"><span>进栈</span></a></h2><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-2.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(LinkStack *S, SElemType e)\n{\n    LinkStackPtr s \n      = (LinkStackPtr)malloc(sizeof(StackNode));\n    s-&gt;data = e;\n    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */\n    s-&gt;next = S-&gt;top;    \n    /* 将新的结点s赋值给栈顶指针，如图中② */\n    S-&gt;top = s;          \n    S-&gt;count++;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="出栈-1" tabindex="-1"><a class="header-anchor" href="#出栈-1"><span>出栈</span></a></h2><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-3.jpg" alt=""></p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(LinkStack *S, SElemType *e)\n{\n    LinkStackPtr p;\n    if (StackEmpty(*S))\n        return ERROR;\n    *e = S-&gt;top-&gt;data;\n    /* 将栈顶结点赋值给p，如图③ */\n    p = S-&gt;top;               \n    /* 使得栈顶指针下移一位，指向后一结点，如图④ */\n    S-&gt;top = S-&gt;top-&gt;next;    \n    /* 释放结点p */\n    free(p);                  \n    S-&gt;count--;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二、队列" tabindex="-1"><a class="header-anchor" href="#二、队列"><span>二、队列</span></a></h2><h3 id="基本概念-6" tabindex="-1"><a class="header-anchor" href="#基本概念-6"><span>基本概念</span></a></h3><p><strong>队列</strong>：只允许在一端插入，在另一端删除</p><p><img src="https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-10-1.jpg" alt=""></p><p><strong>队头</strong>：允许删除的一端</p><p><strong>队尾</strong>：允许插入的一端</p><p><strong>空队列</strong>：不含任何元素的空表</p><h3 id="基本操作-6" tabindex="-1"><a class="header-anchor" href="#基本操作-6"><span>基本操作</span></a></h3><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><pre class="language-plain"><code>InitQueue(*Q):    初始化操作，建立一个空队列Q。\nDestroyQueue(*Q): 若队列Q存在，则销毁它。\nClearQueue(*Q):   将队列Q清空。\nQueueEmpty(Q):    若队列Q为空，返回true，否则返回false。\nGetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。\nEnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。\nDeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。\nQueueLength(Q):   返回队列Q的元素个数\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、数组" tabindex="-1"><a class="header-anchor" href="#三、数组"><span>三、数组</span></a></h2><h2 id="四、串" tabindex="-1"><a class="header-anchor" href="#四、串"><span>四、串</span></a></h2><h2 id="五、树与二叉树" tabindex="-1"><a class="header-anchor" href="#五、树与二叉树"><span>五、树与二叉树</span></a></h2><h2 id="六、图" tabindex="-1"><a class="header-anchor" href="#六、图"><span>六、图</span></a></h2><h2 id="七、查找" tabindex="-1"><a class="header-anchor" href="#七、查找"><span>七、查找</span></a></h2><h2 id="八、排序" tabindex="-1"><a class="header-anchor" href="#八、排序"><span>八、排序</span></a></h2>',216)],a={},d=(0,e(3744).Z)(a,[["render",function(n,i){return(0,s.wg)(),(0,s.iD)("div",null,l)}]])},6363:(n,i,e)=>{e.r(i),e.d(i,{data:()=>s});const s=JSON.parse('{"key":"v-4a421c96","path":"/guide/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html","title":"绪论","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、基本概念","slug":"一、基本概念","link":"#一、基本概念","children":[]},{"level":2,"title":"二、算法","slug":"二、算法","link":"#二、算法","children":[{"level":3,"title":"1.定义","slug":"_1-定义","link":"#_1-定义","children":[]},{"level":3,"title":"2.算法的特性","slug":"_2-算法的特性","link":"#_2-算法的特性","children":[]},{"level":3,"title":"3.算法的要求","slug":"_3-算法的要求","link":"#_3-算法的要求","children":[]}]},{"level":2,"title":"一、基本概念","slug":"一、基本概念-1","link":"#一、基本概念-1","children":[]},{"level":2,"title":"二、基本操作","slug":"二、基本操作","link":"#二、基本操作","children":[]},{"level":2,"title":"三、顺序表","slug":"三、顺序表","link":"#三、顺序表","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"基本操作","slug":"基本操作","link":"#基本操作","children":[]},{"level":3,"title":"读取","slug":"读取","link":"#读取","children":[]},{"level":3,"title":"插入","slug":"插入","link":"#插入","children":[]},{"level":3,"title":"删除","slug":"删除","link":"#删除","children":[]}]},{"level":2,"title":"四、单链表","slug":"四、单链表","link":"#四、单链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-1","link":"#基本概念-1","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-1","link":"#基本操作-1","children":[]},{"level":3,"title":"整表创建","slug":"整表创建","link":"#整表创建","children":[]},{"level":3,"title":"整表删除","slug":"整表删除","link":"#整表删除","children":[]}]},{"level":2,"title":"五、静态链表","slug":"五、静态链表","link":"#五、静态链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-2","link":"#基本概念-2","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-2","link":"#基本操作-2","children":[]}]},{"level":2,"title":"六、循环链表","slug":"六、循环链表","link":"#六、循环链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-3","link":"#基本概念-3","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-3","link":"#基本操作-3","children":[]}]},{"level":2,"title":"七、双向链表","slug":"七、双向链表","link":"#七、双向链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-4","link":"#基本概念-4","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-4","link":"#基本操作-4","children":[]}]},{"level":2,"title":"一、栈","slug":"一、栈","link":"#一、栈","children":[{"level":3,"title":"基本概念","slug":"基本概念-5","link":"#基本概念-5","children":[]}]},{"level":2,"title":"基本操作","slug":"基本操作-5","link":"#基本操作-5","children":[]},{"level":2,"title":"顺序存储","slug":"顺序存储","link":"#顺序存储","children":[]},{"level":2,"title":"结构定义","slug":"结构定义","link":"#结构定义","children":[]},{"level":2,"title":"初始化","slug":"初始化","link":"#初始化","children":[]},{"level":2,"title":"判栈空","slug":"判栈空","link":"#判栈空","children":[]},{"level":2,"title":"进栈","slug":"进栈","link":"#进栈","children":[]},{"level":2,"title":"出栈","slug":"出栈","link":"#出栈","children":[]},{"level":2,"title":"读栈顶元素","slug":"读栈顶元素","link":"#读栈顶元素","children":[]},{"level":2,"title":"共享栈","slug":"共享栈","link":"#共享栈","children":[]},{"level":2,"title":"链式存储","slug":"链式存储","link":"#链式存储","children":[]},{"level":2,"title":"进栈","slug":"进栈-1","link":"#进栈-1","children":[]},{"level":2,"title":"出栈","slug":"出栈-1","link":"#出栈-1","children":[]},{"level":2,"title":"二、队列","slug":"二、队列","link":"#二、队列","children":[{"level":3,"title":"基本概念","slug":"基本概念-6","link":"#基本概念-6","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-6","link":"#基本操作-6","children":[]}]},{"level":2,"title":"三、数组","slug":"三、数组","link":"#三、数组","children":[]},{"level":2,"title":"四、串","slug":"四、串","link":"#四、串","children":[]},{"level":2,"title":"五、树与二叉树","slug":"五、树与二叉树","link":"#五、树与二叉树","children":[]},{"level":2,"title":"六、图","slug":"六、图","link":"#六、图","children":[]},{"level":2,"title":"七、查找","slug":"七、查找","link":"#七、查找","children":[]},{"level":2,"title":"八、排序","slug":"八、排序","link":"#八、排序","children":[]}],"git":{},"filePathRelative":"guide/数据结构/数据结构.md"}')}}]);