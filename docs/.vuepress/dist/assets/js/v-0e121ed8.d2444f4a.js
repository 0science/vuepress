"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[3540],{2872:(i,n,e)=>{e.r(n),e.d(n,{default:()=>J});var l=e(6252);const s=(0,l._)("h2",{id:"单链表",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#单链表"},[(0,l._)("span",null,"单链表")])],-1),d=(0,l._)("h3",{id:"基本概念",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#基本概念"},[(0,l._)("span",null,"基本概念")])],-1),a=(0,l._)("p",null,[(0,l._)("strong",null,"单链表"),(0,l.Uk)("：线性表的链式存储，用任意一组存储单元存储元素")],-1),t=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-7.jpg",height:"120"},null,-1),r=(0,l._)("p",null,[(0,l._)("strong",null,"头指针"),(0,l.Uk)("：链表中第一个节点的存储位置，有头结点则指向头结点("),(0,l._)("strong",null,"必备"),(0,l.Uk)(")")],-1),v=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-8.jpg",height:"40"},null,-1),c=(0,l._)("p",null,[(0,l._)("strong",null,"头结点"),(0,l.Uk)("：单链表第一个结点前附加的一个结点")],-1),u=(0,l._)("p",null,[(0,l._)("strong",null,"数据域"),(0,l.Uk)("：存储信息元素的域("),(0,l._)("strong",null,"p->data"),(0,l.Uk)(")")],-1),m=(0,l._)("p",null,[(0,l._)("strong",null,"指针域"),(0,l.Uk)("：存储直接后继的位置("),(0,l._)("strong",null,"p->next"),(0,l.Uk)(")")],-1),b=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-6-10.jpg",height:"120"},null,-1),p=(0,l._)("p",null,[(0,l._)("strong",null,"空链表")],-1),g=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/20230812133616.png",height:"120"},null,-1),h=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 线性表的单链表存储结构 */\ntypedef struct Node\n{\n    ElemType data;\n    struct Node *next;\n} Node;\n/* 定义LinkList */\ntypedef struct Node *LinkList;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>单链表优缺点</strong></p><ol><li>无需连续存储单元</li><li>指针域会浪费空间</li><li>非随机存取，无法直接查找特定节点</li></ol><h3 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作"><span>基本操作</span></a></h3><h4 id="读取" tabindex="-1"><a class="header-anchor" href="#读取"><span>读取</span></a></h4><ol><li>声明指针p指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则返回结点p的数据</li></ol><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L) */\n/* 操作结果：用e返回L中第i个数据元素的值 */\nStatus GetElem(LinkList L, int i, ElemType *e)\n{\n    int j;\n    LinkList p;            /* 声明一指针p */\n    p = L-&gt;next;        /* 让p指向链表L的第个结点 */\n    j = 1;                 /* j为计数器 */\n    /* p不为空且计数器j还没有等于i时，循环继续 */\n    while (p &amp;&amp; j &lt; i)    \n    {\n        p = p-&gt;next;    /* 让p指向下一个结点 */\n        ++j;\n    }\n    if (!p || j &gt; i)\n        return ERROR;      /* 第i个结点不存在 */\n    *e = p-&gt;data;       /* 取第i个结点的数据 */\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="插入" tabindex="-1"><a class="header-anchor" href="#插入"><span>插入</span></a></h4><p><strong>单链表的插入</strong></p>',9),o=(0,l._)("table",null,[(0,l._)("tr",null,[(0,l._)("td",null,[(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-2.jpg",width:"250"})]),(0,l._)("td",null,[(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-3.jpg",width:"250"})])])],-1),x=(0,l._)("p",null,[(0,l._)("strong",null,"表头/表尾的插入")],-1),L=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-4.jpg",width:"500"},null,-1),j=(0,l.uE)('<ol><li>声明p指针指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则生成空结点s</li><li>s-&gt;data = e</li><li>s-&gt;next = p-&gt;next</li><li>p-&gt;next = s</li><li>返回成功</li></ol><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L)， */\n/* 操作结果：在L中第i个结点位置之前插入新的数\n   据元素e，L的长度加1 */\nStatus ListInsert(LinkList *L, int i, ElemType e)\n{\n    int j;\n    LinkList p, s;\n    p = *L;\n    j = 1;\n    /* 寻找第i-1个结点 */\n    while (p &amp;&amp; j &lt; i)                     \n    {\n        p = p-&gt;next;\n        ++j;\n    }\n    /* 第i个结点不存在 */\n    if (!p || j &gt; i)\n        return ERROR;                      \n    /* 生成新结点（C标准函数） */\n    s = (LinkList)malloc(sizeof(Node));    \n    s-&gt;data = e;\n    /* 将p的后继结点赋值给s的后继 */\n    s-&gt;next = p-&gt;next;                    \n    /* 将s赋值给p的后继 */\n    p-&gt;next = s;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除" tabindex="-1"><a class="header-anchor" href="#删除"><span>删除</span></a></h4>',3),_=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-8-5.jpg",width:"400"},null,-1),f=(0,l.uE)('<ol><li>声明p指针指向头结点，初始化j=1</li><li>j&lt;i时遍历链表，指针p不断向下移动，++j</li><li>p为空时，则i结点不存在</li><li>查找成功，则q = p-&gt;next</li><li>p-&gt;next = q-&gt;next</li><li>e = q-&gt;data</li><li>释放q结点</li><li>返回成功</li></ol><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 初始条件：顺序线性表L已存在，1≤i≤\n   ListLength(L) */\n/* 操作结果：删除L的第i个结点，并用e返回其\n   值，L的长度减1 */\nStatus ListDelete(LinkList *L, int i, ElemType *e)\n{\n    int j;\n    LinkList p, q;\n    p = *L;\n    j = 1;\n    /* 遍历寻找第i-1个结点 */\n    while (p-&gt;next &amp;&amp; j &lt; i)    \n    {\n        p = p-&gt;next;\n        ++j;\n    }\n    /* 第i个结点不存在 */\n    if (!(p-&gt;next) || j &gt; i)\n        return ERROR;           \n    q = p-&gt;next;\n    /* 将q的后继赋值给p的后继 */\n    p-&gt;next = q-&gt;next;          \n    /* 将q结点中的数据给e */\n    *e = q-&gt;data;               \n    /* 让系统回收此结点，释放内存 */\n    free(q);                    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="整表创建" tabindex="-1"><a class="header-anchor" href="#整表创建"><span>整表创建</span></a></h4><p><strong>头插法</strong></p>',4),k=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-9-1.jpg",width:"400"},null,-1),q=(0,l.uE)('<ol><li>声明指针p和变量i</li><li>初始化空链表L</li><li>建立带头结点的空表(头结点指向NULL)</li><li>循环： <ol><li>生成新节点，并赋值给p</li><li>随机生成数赋值给p的数据域</li><li>将p插入到头结点与新结点之间</li></ol></li></ol><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 随机产生n个元素的值，建立带表头结点的单链\n   线性表L（头插法） */\nvoid CreateListHead(LinkList *L, int n)\n{\n    LinkList p;\n    int i;\n    /* 初始化随机数种子 */\n    srand(time(0));                            \n    *L = (LinkList)malloc(sizeof(Node));\n    /* 先建立一个带头结点的单链表 */\n    (*L)-&gt;next = NULL;                         \n    for (i = 0; i &lt; n; i++)\n    {\n        /* 生成新结点 */\n        p = (LinkList)malloc(sizeof(Node));    \n        /* 随机生成100以内的数字 */\n        p-&gt;data = rand() % 100 + 1;            \n        p-&gt;next = (*L)-&gt;next;\n        /* 插入到表头 */\n        (*L)-&gt;next = p;                        \n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>尾插法</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 随机产生n个元素的值，建立带表头结点的单链\n线性表L（尾插法） */\nvoid CreateListTail(LinkList *L, int n)\n{\n    LinkList p,r;\n    int i;\n    /* 初始化随机数种子 */\n    srand(time(0));                         \n    /* 为整个线性表 */\n    *L = (LinkList)malloc(sizeof(Node));    \n    /* r为指向尾部的结点 */\n    r = *L;                                 \n    for (i = 0; i &lt; n; i++)\n    {\n        /* 生成新结点 */\n        p = (Node *)malloc(sizeof(Node));   \n        /* 随机生成100以内的数字 */\n        p-&gt;data = rand() % 100 + 1;         \n        /* 将表尾终端结点的指针指向新结点 */\n        r-&gt;next = p;                        \n        /* 将当前的新结点定义为表尾终端结点 */\n        r = p;                              \n    }\n    /* 表示当前链表结束 */\n    r-&gt;next = NULL;                         \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="整表删除" tabindex="-1"><a class="header-anchor" href="#整表删除"><span>整表删除</span></a></h4><ol><li>声明指针p和q</li><li>将头结点赋值给p</li><li>循环： <ol><li>将下一结点赋值给q</li><li>释放p</li><li>将q赋值给p</li></ol></li></ol><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 初始条件：顺序线性表L已存在，操作结果：将L\n   重置为空表 */\nStatus ClearList(LinkList *L)\n{\n    LinkList p, q;\n    /* p指向第一个结点 */\n    p = (*L)-&gt;next;       \n    /* 没到表尾 */\n    while (p)             \n    {\n        q = p-&gt;next;\n        free(p);\n        p=q;\n    }\n    /* 头结点指针域为空 */\n    (*L)-&gt;next = NULL;    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>线性表</th><th>存储方式</th><th>时间性能</th><th>空间性能</th><th>适用</th></tr></thead><tbody><tr><td>顺序表</td><td>连续存储</td><td>查找O(1)<br>插入O(n)<br>删除O(n)</td><td>预分配空间</td><td>频繁查找，很少插入删除</td></tr><tr><td>单链表</td><td>链式存储</td><td>查找O(n)<br>插入O(n)<br>删除O(n)</td><td>自由分配空间</td><td>元素个数多，变化大</td></tr></tbody></table><h2 id="静态链表" tabindex="-1"><a class="header-anchor" href="#静态链表"><span>静态链表</span></a></h2><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1"><span>基本概念</span></a></h3><p><strong>静态链表</strong>：用数组描述的链表</p>',11),E=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-1.jpg",height:"150"},null,-1),y=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 线性表的静态链表存储结构 */\n/* 假设链表的最大长度是1000 */\n#define MAXSIZE 1000                     \ntypedef struct\n{\n    ElemType data;\n    /* 游标（Cursor），为0时表示无指向 */\n    int cur;                             \n} Component, \n  /* 对于不提供结构struct的程序设计语言，\n     可以使用一对并行数组data和cur来处理。 */\n  StaticLinkList[MAXSIZE];\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',1),w=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg",height:"120"},null,-1),S=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 若备用空间链表非空，则返回分配的结点下标，\n   否则返回0 */\nint Malloc_SLL(StaticLinkList space)\n{\n    /* 当前数组第一个元素的cur存的值， */\n    /* 就是要返回的第一个备用空闲的下标 */\n    int i = space[0].cur;               \n    /* 由于要拿出一个分量来使用了，所以我们 */\n    /* 就得把它的下一个分量用来做备用 */\n    if (space[0].cur)\n        space[0].cur = space[i].cur;    \n    return i;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>静态链表的优缺点</strong></p><ol><li>插入删除只改游标，不动元素</li><li>无法确定表长</li><li>无法随机读取</li></ol><h3 id="基本操作-1" tabindex="-1"><a class="header-anchor" href="#基本操作-1"><span>基本操作</span></a></h3><h4 id="插入-1" tabindex="-1"><a class="header-anchor" href="#插入-1"><span>插入</span></a></h4>',5),N=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-3.jpg",height:"120"},null,-1),O=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 若备用空间链表非空，则返回分配的结点下标，\n   否则返回0 */\nint Malloc_SLL(StaticLinkList space)\n{\n    /* 当前数组第一个元素的cur存的值， */\n    /* 就是要返回的第一个备用空闲的下标 */\n    int i = space[0].cur;               \n    /* 由于要拿出一个分量来使用了，所以我们 */\n    /* 就得把它的下一个分量用来做备用 */\n    if (space[0].cur)\n        space[0].cur = space[i].cur;    \n    return i;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 在L中第i个元素之前插入新的数据元素e  */\n  Status ListInsert(StaticLinkList L, int i, ElemType e)\n  {\n      int j, k, l;\n      /* 注意k首先是最后一个元素的下标 */\n      k = MAX_SIZE - 1;                   \n      if (i &lt; 1 || i &gt; ListLength(L) + 1)\n          return ERROR;\n      /* 获得空闲分量的下标 */\n      j = Malloc_SSL(L);                  \n      if (j)\n      {\n         /* 将数据赋值给此分量的data */\n         L[j].data = e;                  \n         /* 找到第i个元素之前的位置 */\n         for (l = 1; l &lt;= i - 1; l++)    \n             k = L[k].cur;\n         /* 把第i个元素之前的cur赋值给新元素的cur */\n         L[j].cur = L[k].cur;        \n         /* 把新元素的下标赋值给第i个元素之前元素的cur */\n         L[k].cur = j;                   \n         return OK;\n     }\n     return ERROR;\n }\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除-1" tabindex="-1"><a class="header-anchor" href="#删除-1"><span>删除</span></a></h4>',3),R=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-12-4.jpg",height:"80"},null,-1),W=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 删除在L中第i个数据元素e */\nStatus ListDelete(StaticLinkList L, int i)\n{\n    int j, k;\n    if (i &lt; 1 || i &gt; ListLength(L))\n        return ERROR;\n    k = MAX_SIZE - 1;\n    for (j = 1; j &lt;= i - 1; j++)\n        k = L[k].cur;\n    j = L[k].cur;\n    L[k].cur = L[j].cur;\n    Free_SSL(L, j);\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 将下标为k的空闲结点回收到备用链表 */\nvoid Free_SSL(StaticLinkList space, int k)\n{\n    /* 把第一个元素cur值赋给要删除的分量cur */\n    space[k].cur = space[0].cur;    \n    /* 把要删除的分量下标赋值给第一个元素的cur */\n    space[0].cur = k;               \n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 初始条件：静态链表L已存在。操作结果：返回L\n   中数据元素个数 */\nint ListLength(StaticLinkList L)\n{\n    int j = 0;\n    int i = L[MAXSIZE - 1].cur;\n    while (i)\n    {\n        i = L[i].cur;\n        j++;\n    }\n    return j;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="循环链表" tabindex="-1"><a class="header-anchor" href="#循环链表"><span>循环链表</span></a></h2><h3 id="基本概念-2" tabindex="-1"><a class="header-anchor" href="#基本概念-2"><span>基本概念</span></a></h3><p><strong>循环链表</strong>：将链表末端空指针改为指向头节点</p><p><strong>空循环链表</strong></p>',7),A=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-3.jpg",height:"60"},null,-1),U=(0,l._)("p",null,[(0,l._)("strong",null,"非空循环链表")],-1),B=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-4.jpg",height:"70"},null,-1),D=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-5.jpg",height:"70"},null,-1),C=(0,l._)("h3",{id:"基本操作-2",tabindex:"-1"},[(0,l._)("a",{class:"header-anchor",href:"#基本操作-2"},[(0,l._)("span",null,"基本操作")])],-1),M=(0,l._)("p",null,[(0,l._)("strong",null,"合并链表")],-1),T=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-13-7.jpg",height:"180"},null,-1),I=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 保存A表的头结点，即① */\np = rearA-&gt;next;                    \n/*将本是指向B表的第一个结点（不是头结点） */\nrearA-&gt;next = rearB-&gt;next-&gt;next;    \n/* 赋值给reaA-&gt;next，即② */\nq = rearB-&gt;next;\n/* 将原A表的头结点赋值给rearB-&gt;next，即③ */\nrearB-&gt;next = p;                    \n/* 释放q */\nfree(q);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="双向链表" tabindex="-1"><a class="header-anchor" href="#双向链表"><span>双向链表</span></a></h2><h3 id="基本概念-3" tabindex="-1"><a class="header-anchor" href="#基本概念-3"><span>基本概念</span></a></h3><p><strong>双向链表</strong>：单链表的每个结点中设置一个指向前驱的指针域</p><p><strong>空双向链表</strong></p>',5),K=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-3.jpg",height:"80"},null,-1),Z=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 线性表的双向链表存储结构 */\ntypedef struct DulNode\n{\n    ElemType data;\n    struct DuLNode *prior;    /* 直接前驱指针 */\n    struct DuLNode *next;     /* 直接后继指针 */\n} DulNode, *DuLinkList;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基本操作-3" tabindex="-1"><a class="header-anchor" href="#基本操作-3"><span>基本操作</span></a></h3><h4 id="插入-2" tabindex="-1"><a class="header-anchor" href="#插入-2"><span>插入</span></a></h4>',3),z=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-5.jpg",height:"200"},null,-1),X=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 把p赋值给s的前驱，如图中① */\ns-&gt;prior = p;          \n/* 把p-&gt;next赋值给s的后继，如图中② */\ns-&gt;next = p-&gt;next;     \n/* 把s赋值给p-&gt;next的前驱，如图中③ */\np-&gt;next-&gt;prior = s;    \n/* 把s赋值给p的后继，如图中④ */\np-&gt;next = s;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除-2" tabindex="-1"><a class="header-anchor" href="#删除-2"><span>删除</span></a></h4>',2),F=(0,l._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/3-14-6.jpg",height:"150"},null,-1),G=(0,l.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */\np-&gt;prior-&gt;next = p-&gt;next;     \n/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */\np-&gt;next-&gt;prior = p-&gt;prior;    \n/* 释放结点 */\nfree(p);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',1),H={},J=(0,e(3744).Z)(H,[["render",function(i,n){const e=(0,l.up)("center");return(0,l.wg)(),(0,l.iD)("div",null,[s,d,a,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[t])),_:1}),r,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[v])),_:1}),c,u,m,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[b])),_:1}),p,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[g])),_:1}),h,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[o])),_:1}),x,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[L])),_:1}),j,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[_])),_:1}),f,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[k])),_:1}),q,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[E])),_:1}),y,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[w])),_:1}),S,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[N])),_:1}),O,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[R])),_:1}),W,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[A])),_:1}),U,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[B])),_:1}),(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[D])),_:1}),C,M,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[T])),_:1}),I,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[K])),_:1}),Z,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[z])),_:1}),X,(0,l.Wm)(e,null,{default:(0,l.w5)((()=>[F])),_:1}),G])}]])},3768:(i,n,e)=>{e.r(n),e.d(n,{data:()=>l});const l=JSON.parse('{"key":"v-0e121ed8","path":"/guide/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"单链表","slug":"单链表","link":"#单链表","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"基本操作","slug":"基本操作","link":"#基本操作","children":[]}]},{"level":2,"title":"静态链表","slug":"静态链表","link":"#静态链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-1","link":"#基本概念-1","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-1","link":"#基本操作-1","children":[]}]},{"level":2,"title":"循环链表","slug":"循环链表","link":"#循环链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-2","link":"#基本概念-2","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-2","link":"#基本操作-2","children":[]}]},{"level":2,"title":"双向链表","slug":"双向链表","link":"#双向链表","children":[{"level":3,"title":"基本概念","slug":"基本概念-3","link":"#基本概念-3","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-3","link":"#基本操作-3","children":[]}]}],"git":{},"filePathRelative":"guide/数据结构/链表.md"}')}}]);