"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[383],{6115:(e,n,i)=>{i.r(n),i.d(n,{default:()=>k});var s=i(6252);const a=(0,s.uE)('<h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈"><span>栈</span></a></h2><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p><strong>栈</strong>：只允许在一段插入或删除的线性表(后进先出)</p><p><strong>进栈(push)</strong>：栈的插入</p><p><strong>出栈(pop)</strong>：栈的删除</p><p><strong>栈顶</strong>：允许插入或删除的一段</p><p><strong>栈底</strong>：不允许插入或删除的一段</p><p><strong>空栈</strong>：不含任何元素的空表</p><p><strong>顺序栈</strong>：采用顺序存储的栈</p><p><strong>共享栈</strong>：可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分 别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</p>',10),d=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-5-1.jpg",height:"100"},null,-1),l=(0,s._)("p",null,[(0,s._)("strong",null,"链栈"),(0,s.Uk)("：采用链式存储的栈")],-1),t=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-1.jpg",height:"250"},null,-1),r=(0,s.uE)('<h3 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作"><span>基本操作</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>InitStack(*S):    初始化操作，建立一个空栈S。\nDestroyStack(*S): 若栈存在，则销毁它。\nClearStack(*S):   将栈清空。\nStackEmpty(S):    若栈为空，返回true，否则返回false。\nGetTop(S, *e):    若栈存在且非空，用e返回S的栈顶元素。\nPush(*S, e):      若栈S存在，插入新元素e到栈S中并成为栈顶元素。\nPop(*S, *e):      删除栈S中栈顶元素，并用e返回其值。\nStackLength(S):   返回栈S的元素个数。\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="顺序存储" tabindex="-1"><a class="header-anchor" href="#顺序存储"><span>顺序存储</span></a></h3><h4 id="结构定义" tabindex="-1"><a class="header-anchor" href="#结构定义"><span>结构定义</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* SElemType类型根据实际情况而定，这里假设为int */\ntypedef int SElemType;    \ntypedef struct\n{\n    SElemType data[MAXSIZE];\n    /* 用于栈顶指针 */\n    int top;              \n}SqStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>栈顶指针：S.top 初始时设置：S.top=-1 栈顶元素：S.data[S.top] 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素 出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1 栈空条件：S.top==-1 栈满条件：S.top==MaxSize-1 栈长：S.top+1</p><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>void Initstack(SqStack &amp;S){\n\tS.top=-1;                //初始化栈顶指针\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="判栈空" tabindex="-1"><a class="header-anchor" href="#判栈空"><span>判栈空</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>bool StackEmpty(Sqstack S){\n\tif(S.top==-1)            //栈空\n\t\treturn true;\n\telse                     //不空\n\t\treturn false;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="进栈" tabindex="-1"><a class="header-anchor" href="#进栈"><span>进栈</span></a></h4>',11),v=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-2.jpg",height:"200"},null,-1),c=(0,s.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(SqStack *S, SElemType e)\n{\n    /* 栈满 */\n    if (S-&gt;top == MAXSIZE - 1)    \n    {\n        return ERROR;\n    }\n    /* 栈顶指针增加一 */\n    S-&gt;top++;                     \n    /* 将新插入元素赋值给栈顶空间 */\n    S-&gt;data[S-&gt;top] = e;          \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="出栈" tabindex="-1"><a class="header-anchor" href="#出栈"><span>出栈</span></a></h4>',2),u=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-2-3.jpg",height:"200"},null,-1),m=(0,s.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(SqStack *S, SElemType *e)\n{\n    if (S-&gt;top == -1)\n        return ERROR;\n    /* 将要删除的栈顶元素赋值给e */\n    *e = S-&gt;data[S-&gt;top];    \n    /* 栈顶指针减一 */\n    S-&gt;top--;                \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读栈顶元素" tabindex="-1"><a class="header-anchor" href="#读栈顶元素"><span>读栈顶元素</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>bool GetTop(SqStack S,ElemType &amp;x){\n\tif(S.top==-1)                   //栈空，报错\n\t\treturn false;\n\tx=S.data[S.top];                //x记录栈顶元素\n\t\treturn true;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="共享栈" tabindex="-1"><a class="header-anchor" href="#共享栈"><span>共享栈</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 两栈共享空间结构 */\ntypedef struct\n{\n    SElemType data[MAXSIZE];\n    int top1;    /* 栈1栈顶指针 */\n    int top2;    /* 栈2栈顶指针 */\n} SqDoubleStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(SqDoubleStack *S, SElemType e, \nint stackNumber)\n{\n    /* 栈已满，不能再push新元素了 */\n    if (S-&gt;top1 + 1 == S-&gt;top2)    \n        return ERROR;\n    /* 栈1有元素进栈 */\n    if (stackNumber == 1)          \n        /* 若栈1则先top1+1后给数组元素赋值 */\n        S-&gt;data[++S-&gt;top1] = e;    \n    /* 栈2有元素进栈 */\n    else if (stackNumber == 2)     \n        /* 若栈2则先top2-1后给数组元素赋值 */\n        S-&gt;data[--S-&gt;top2] = e;    \n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(SqDoubleStack *S, SElemType *e, int stackNumber)\n{\n    if (stackNumber == 1)\n    {\n        /* 说明栈1已经是空栈，溢出 */\n        if (S-&gt;top1 == -1)\n            return ERROR;           \n        /* 将栈1的栈顶元素出栈 */\n        *e = S-&gt;data[S-&gt;top1--];    \n    }\n    else if (stackNumber == 2)\n    {\n        /* 说明栈2已经是空栈，溢出 */\n        if (S-&gt;top2 == MAXSIZE)\n            return ERROR;           \n        /* 将栈2的栈顶元素出栈 */\n        *e = S-&gt;data[S-&gt;top2++];    \n    }\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="链式存储" tabindex="-1"><a class="header-anchor" href="#链式存储"><span>链式存储</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>typedef struct StackNode\n{\n    SElemType data;\n    struct StackNode *next;\n} StackNode, *LinkStackPtr;\ntypedef struct LinkStack\n{\n    LinkStackPtr top;\n    int count;\n} LinkStack;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="进栈-1" tabindex="-1"><a class="header-anchor" href="#进栈-1"><span>进栈</span></a></h4>',10),b=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-2.jpg",height:"250"},null,-1),p=(0,s.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 插入元素e为新的栈顶元素 */\nStatus Push(LinkStack *S, SElemType e)\n{\n    LinkStackPtr s \n      = (LinkStackPtr)malloc(sizeof(StackNode));\n    s-&gt;data = e;\n    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */\n    s-&gt;next = S-&gt;top;    \n    /* 将新的结点s赋值给栈顶指针，如图中② */\n    S-&gt;top = s;          \n    S-&gt;count++;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="出栈-1" tabindex="-1"><a class="header-anchor" href="#出栈-1"><span>出栈</span></a></h4>',2),o=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-6-3.jpg",height:"250"},null,-1),g=(0,s.uE)('<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>/* 若栈不空，则删除S的栈顶元素，用e返回其值，\n   并返回OK；否则返回ERROR */\nStatus Pop(LinkStack *S, SElemType *e)\n{\n    LinkStackPtr p;\n    if (StackEmpty(*S))\n        return ERROR;\n    *e = S-&gt;top-&gt;data;\n    /* 将栈顶结点赋值给p，如图③ */\n    p = S-&gt;top;               \n    /* 使得栈顶指针下移一位，指向后一结点，如图④ */\n    S-&gt;top = S-&gt;top-&gt;next;    \n    /* 释放结点p */\n    free(p);                  \n    S-&gt;count--;\n    return OK;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列"><span>队列</span></a></h2><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1"><span>基本概念</span></a></h3><p><strong>队列</strong>：只允许在一端插入，在另一端删除</p>',4),h=(0,s._)("img",{src:"https://djm-1317856319.cos.ap-shanghai.myqcloud.com/djm-1317856319/4-10-1.jpg",height:"100"},null,-1),S=(0,s.uE)('<p><strong>队头</strong>：允许删除的一端</p><p><strong>队尾</strong>：允许插入的一端</p><p><strong>空队列</strong>：不含任何元素的空表</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="基本操作-1" tabindex="-1"><a class="header-anchor" href="#基本操作-1"><span>基本操作</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>InitQueue(*Q):    初始化操作，建立一个空队列Q。\nDestroyQueue(*Q): 若队列Q存在，则销毁它。\nClearQueue(*Q):   将队列Q清空。\nQueueEmpty(Q):    若队列Q为空，返回true，否则返回false。\nGetHead(Q, *e):   若队列Q存在且非空，用e返回队列Q的队头元素。\nEnQueue(*Q, e):   若队列Q存在，插入新元素e到队列Q中并成为队尾元素。\nDeQueue(*Q, *e):  删除队列Q中队头元素，并用e返回其值。\nQueueLength(Q):   返回队列Q的元素个数\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',6),x={},k=(0,i(3744).Z)(x,[["render",function(e,n){const i=(0,s.up)("center");return(0,s.wg)(),(0,s.iD)("div",null,[a,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[d])),_:1}),l,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[t])),_:1}),r,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[v])),_:1}),c,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[u])),_:1}),m,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[b])),_:1}),p,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[o])),_:1}),g,(0,s.Wm)(i,null,{default:(0,s.w5)((()=>[h])),_:1}),S])}]])},8594:(e,n,i)=>{i.r(n),i.d(n,{data:()=>s});const s=JSON.parse('{"key":"v-0adac565","path":"/guide/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"栈","slug":"栈","link":"#栈","children":[{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"基本操作","slug":"基本操作","link":"#基本操作","children":[]},{"level":3,"title":"顺序存储","slug":"顺序存储","link":"#顺序存储","children":[]},{"level":3,"title":"链式存储","slug":"链式存储","link":"#链式存储","children":[]}]},{"level":2,"title":"队列","slug":"队列","link":"#队列","children":[{"level":3,"title":"基本概念","slug":"基本概念-1","link":"#基本概念-1","children":[]},{"level":3,"title":"基本操作","slug":"基本操作-1","link":"#基本操作-1","children":[]}]}],"git":{},"filePathRelative":"guide/数据结构/栈和队列.md"}')}}]);